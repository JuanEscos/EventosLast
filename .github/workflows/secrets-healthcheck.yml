name: Secrets Healthcheck (FTP)

on:
  workflow_dispatch:

jobs:
  probe:
    runs-on: ubuntu-24.04
    env:
      # Ajusta si usas ftps o sftp (y mira la nota al final)
      FTP_SCHEME: ftp
      REMOTE_DIR: /Competiciones/EventsPast/data

      # Secrets a probar (creados en este repo: Settings ‚Üí Secrets and variables ‚Üí Actions)
      FTP_HOST: ${{ secrets.FTP_HOST }}
      FTP_USER: ${{ secrets.FTP_USER }}
      FTP_PASS: ${{ secrets.FTP_PASS }}

    steps:
      - name: ¬øEst√°n definidos los secrets? (sin imprimir valores)
        shell: bash
        run: |
          set -euo pipefail
          check() { var="$1"; if [ -n "${!var-}" ]; then echo "‚úÖ $var definido"; else echo "‚ùå $var vac√≠o o no existe"; fi; }
          check FTP_HOST
          check FTP_USER
          check FTP_PASS

      - name: Validaci√≥n de formato (CR/LF, espacios al inicio/fin)
        shell: bash
        run: |
          set -euo pipefail

          has_cr()     { printf '%s' "$1" | tr -d -c '\r' | wc -c; }
          has_lf()     { printf '%s' "$1" | tr -d -c '\n' | wc -c; }
          len()        { printf '%s' "$1" | wc -c; }
          lead_space() { case "$1" in " "*) echo 1 ;; $'\t'*) echo 1 ;; *) echo 0 ;; esac; }
          trail_space(){ case "$1" in *" " | *$'\t') echo 1 ;; *) echo 0 ;; esac; }

          for v in FTP_HOST FTP_USER FTP_PASS REMOTE_DIR; do
            val="${!v-}"
            echo "‚Ä¢ $v ‚Üí length=$(len "$val"), CR=$(has_cr "$val"), LF=$(has_lf "$val"), leading_space=$(lead_space "$val"), trailing_space=$(trail_space "$val")"
          done

          # Falla si detecta CR/LF o espacios indebidos
          for v in FTP_HOST FTP_USER FTP_PASS REMOTE_DIR; do
            val="${!v-}"
            if [ "$(has_cr "$val")" -gt 0 ] || [ "$(has_lf "$val")" -gt 0 ]; then
              echo "‚ùå $v contiene CR/LF. Edita el secret/ruta y quita retornos."; exit 1
            fi
            if [ "$(lead_space "$val")" -gt 0 ] || [ "$(trail_space "$val")" -gt 0 ]; then
              echo "‚ùå $v tiene espacios al inicio/fin. Corrige el valor."; exit 1
            fi
          done

      - name: Normaliza ruta remota
        id: norm
        shell: bash
        run: |
          set -euo pipefail
          REMOTE_DIR="${REMOTE_DIR:-/}"
          [[ "$REMOTE_DIR" != /* ]] && REMOTE_DIR="/$REMOTE_DIR"
          REMOTE_DIR="$(echo "$REMOTE_DIR" | sed 's://*:/:g; s:/*$::')"
          echo "REMOTE_DIR_NORM=$REMOTE_DIR" >> "$GITHUB_OUTPUT"

      - name: Dry-run de conexi√≥n y listado remoto (sin exponer credenciales)
        shell: bash
        env:
          REMOTE_DIR_NORM: ${{ steps.norm.outputs.REMOTE_DIR_NORM }}
        run: |
          set -euo pipefail

          [[ -z "${FTP_HOST:-}" ]] && { echo "‚ùå Falta FTP_HOST"; exit 1; }
          [[ -z "${FTP_USER:-}" ]] && { echo "‚ùå Falta FTP_USER"; exit 1; }
          [[ -z "${FTP_PASS:-}" ]] && { echo "‚ùå Falta FTP_PASS"; exit 1; }

          URL="${FTP_SCHEME}://${FTP_HOST}${REMOTE_DIR_NORM}/"
          echo "üîó Probar√©: $URL"

          CURL_OPTS=( -sS --fail --show-error --user "$FTP_USER:$FTP_PASS" )

          case "$FTP_SCHEME" in
            ftp|ftps)
              # Para ftp/ftps listamos el directorio (no sube nada). --ftp-method nocwd evita cambios de dir raros.
              CURL_OPTS+=( --ftp-method nocwd --list-only )
              ;;
            sftp)
              # sftp tambi√©n admite listado con curl; si falla, crea la carpeta antes con tu cliente SFTP.
              :
              ;;
            *)
              echo "‚ùå Esquema no soportado: $FTP_SCHEME"; exit 1;;
          esac

          # Ejecuta el listado; si credenciales/URL est√°n mal, salta con c√≥digo ‚â† 0
          if curl "${CURL_OPTS[@]}" "$URL" > /dev/null; then
            echo "‚úÖ Conexi√≥n y ruta remota OK"
          else
            echo "‚ùå Fallo de conexi√≥n/listado (revisa host, esquema, puerto, firewall o credenciales)"; exit 1
          fi
